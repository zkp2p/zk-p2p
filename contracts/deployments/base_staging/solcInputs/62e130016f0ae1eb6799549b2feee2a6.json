{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@zk-email/contracts/utils/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6;\n\n// https://github.com/nalinbhardwaj/ethdosnumber/blob/main/ethdos-contracts/src/HexStrings.sol\nlibrary StringUtils {\n    bytes16 internal constant ALPHABET = \"0123456789abcdef\";\n    uint256 internal constant DEFAULT_PACK_SIZE = 31;\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(bytes32 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(address account) internal pure returns (string memory) {\n        return toString(abi.encodePacked(account));\n    }\n\n    function stringEq(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n\n    function toString(bytes memory data) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    // 1 packed byte = packSize (usually 31) normal bytes, all in one 255/256-bit value\n    // Note that this is not 32 due to the field modulus of circom\n    function convertPackedByteToString(uint256 packedByte, uint256 packSize)\n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        uint256[] memory packedBytes = new uint256[](1);\n        packedBytes[0] = packedByte;\n        return convertPackedBytesToString(packedBytes, packSize, packSize);\n    }\n\n    // Note: This convenience function removes the max string length check, which may cause misalignment with the circom\n    // If using this, then the circom needs to rangecheck packed length in the circuit itself\n    // This defaults to 31 bytes per packed byte\n    function convertPackedBytesToString(uint256[] memory packedBytes) \n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        return convertPackedBytesToString(packedBytes, packedBytes.length * DEFAULT_PACK_SIZE, DEFAULT_PACK_SIZE);\n    }\n\n    // Unpacks uint256s into bytes and then extracts the non-zero characters\n    // Only extracts contiguous non-zero characters and ensures theres only 1 such state\n    // Note that unpackedLen may be more than packedBytes.length * 8 since there may be 0s\n    // signals is the total number of signals (i.e. bytes) packed into the packedBytes. it defaults to packedBytes.length * packSize\n    function convertPackedBytesToString(uint256[] memory packedBytes, uint256 signals, uint256 packSize)\n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        uint8 state = 0;\n        // bytes: 0 0 0 0 y u s h _ g 0 0 0\n        // state: 0 0 0 0 1 1 1 1 1 1 2 2 2\n        bytes memory nonzeroBytesArray = new bytes(packedBytes.length * packSize);\n        uint256 nonzeroBytesArrayIndex = 0;\n        for (uint16 i = 0; i < packedBytes.length; i++) {\n            uint256 packedByte = packedBytes[i];\n            uint8[] memory unpackedBytes = new uint8[](packSize);\n            for (uint256 j = 0; j < packSize; j++) {\n                unpackedBytes[j] = uint8(packedByte >> (j * 8));\n            }\n            for (uint256 j = 0; j < packSize; j++) {\n                uint256 unpackedByte = unpackedBytes[j]; //unpackedBytes[j];\n                if (unpackedByte != 0) {\n                    nonzeroBytesArray[nonzeroBytesArrayIndex] = bytes1(uint8(unpackedByte));\n                    nonzeroBytesArrayIndex++;\n                    if (state % 2 == 0) {\n                        state += 1;\n                    }\n                } else {\n                    if (state % 2 == 1) {\n                        state += 1;\n                    }\n                }\n                packedByte = packedByte >> 8;\n            }\n        }\n        // TODO: You might want to assert that the state is exactly 1 or 2\n        // If not, that means empty bytse have been removed from the middle and things have been concatenated.\n        // We removed due to some tests failing, but this is not ideal and the require should be uncommented as soon as tests pass with it.\n\n        // require(state == 1 || state == 2, \"Invalid final state of packed bytes in email; more than two non-zero regions found!\");\n        require(state >= 1, \"No packed bytes found! Invalid final state of packed bytes in email; value is likely 0!\");\n        require(nonzeroBytesArrayIndex <= signals, \"Packed bytes more than allowed max number of signals!\");\n        string memory returnValue = removeTrailingZeros(string(nonzeroBytesArray));\n        return returnValue;\n        // Have to end at the end of the email -- state cannot be 1 since there should be an email footer\n    }\n\n    function bytes32ToString(bytes32 input) internal pure returns (string memory) {\n        uint256 i;\n        for (i = 0; i < 32 && input[i] != 0; i++) {}\n        bytes memory resultBytes = new bytes(i);\n        for (i = 0; i < 32 && input[i] != 0; i++) {\n            resultBytes[i] = input[i];\n        }\n        return string(resultBytes);\n    }\n\n    // sliceArray is used to slice an array of uint256s from start-end into a new array of uint256s\n    function sliceArray(uint256[] memory input, uint256 start, uint256 end) internal pure returns (uint256[] memory) {\n        require(start <= end && end <= input.length, \"Invalid slice indices\");\n        uint256[] memory result = new uint256[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            result[i - start] = input[i];\n        }\n        return result;\n    }\n\n    // stringToUint is used to convert a string like \"45\" to a uint256 4\n    function stringToUint(string memory s) internal pure returns (uint256) {\n        bytes memory b = bytes(s);\n        uint256 result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                result = result * 10 + (uint256(uint8(b[i])) - 48);\n            }\n\n            // TODO: Currently truncates decimals\n            if (b[i] == 0x2E) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    // getDomainFromEmail is used to extract the domain from an email i.e. the part after the @\n    function getDomainFromEmail(string memory fromEmail) internal pure returns (string memory) {\n        bytes memory emailBytes = bytes(fromEmail);\n        uint256 atIndex;\n        for (uint256 i = 0; i < emailBytes.length; i++) {\n            if (emailBytes[i] == \"@\") {\n                atIndex = i;\n                break;\n            }\n        }\n\n        bytes memory domainBytes = new bytes(emailBytes.length - atIndex - 1);\n        for (uint256 j = 0; j < domainBytes.length; j++) {\n            domainBytes[j] = emailBytes[atIndex + 1 + j];\n        }\n        return bytes32ToString(bytes32(bytes(domainBytes)));\n    }\n\n    function removeTrailingZeros(string memory input) public pure returns (string memory) {\n        bytes memory inputBytes = bytes(input);\n        uint256 endIndex = inputBytes.length;\n\n        for (uint256 i = 0; i < inputBytes.length; i++) {\n            if (inputBytes[i] == 0) {\n                endIndex = i;\n                break;\n            }\n        }\n\n        bytes memory resultBytes = new bytes(endIndex);\n        for (uint256 i = 0; i < endIndex; i++) {\n            resultBytes[i] = inputBytes[i];\n        }\n\n        return string(resultBytes);\n    }\n\n    // Upper/lower string utils from https://github.com/willitscale/solidity-util/blob/master/lib/Strings.sol\n    /**\n     * Upper\n     *\n     * Converts all the values of a string to their corresponding upper case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to upper case\n     * @return string\n     */\n    function upper(string memory _base) public pure returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _upper(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Lower\n     *\n     * Converts all the values of a string to their corresponding lower case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to lower case\n     * @return string\n     */\n    function lower(string memory _base) public pure returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Upper\n     *\n     * Convert an alphabetic character to upper case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to upper case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a lower case otherwise returns the original value\n     */\n    function _upper(bytes1 _b1) private pure returns (bytes1) {\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\n            return bytes1(uint8(_b1) - 32);\n        }\n\n        return _b1;\n    }\n\n    /**\n     * Lower\n     *\n     * Convert an alphabetic character to lower case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to lower case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a upper case otherwise returns the original value\n     */\n    function _lower(bytes1 _b1) private pure returns (bytes1) {\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n"
    },
    "contracts/external/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ----------------------------------------------------------------------------\n// DateTime Library v2.0\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n//\n// NOTE: This library has been pruned to keep only functions needed by zkp2p\n// ----------------------------------------------------------------------------\n\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day - 32075 + (1461 * (_year + 4800 + (_month - 14) / 12)) / 4\n            + (367 * (_month - 2 - ((_month - 14) / 12) * 12)) / 12\n            - (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) / 4 - OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    )\n        internal\n        pure\n        returns (uint256 timestamp)\n    {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR\n            + minute * SECONDS_PER_MINUTE + second;\n    }\n}\n"
    },
    "contracts/lib/StringConversionUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n// Building on zk-email's StringUtils library we add the ability to handle decimals when\n// converting from string to Uint\nlibrary StringConversionUtils {\n    \n    /**\n     * @notice Function that parses numbers returned as strings including floating point numbers. Returned floating point\n     * numbers are to have the desired amount of decimal specified. If the stringified version of the floating point\n     * number has more decimal places than desired then the function will revert in order to be maximally safe. If\n     * the returned number has multiple floating points then the function will revert.\n     *\n     * Examples: _s = \"12.34\", _expectedDecimals = 6 => 12340000\n     *           _s = \"12.34\", _expectedDecimals = 2 => 1234\n     *           _s = \"12.34\", _expectedDecimals = 1 => REVERT (we never want loss of precision only addition)\n     *           _s = \"12.34.56\", _expectedDecimals = 6 => REVERT (Invalid number)\n     *\n     * @param _s                    String being processed\n     * @param _desiredDecimals      Desired amount of decimal places\n     */\n    function stringToUint(string memory _s, uint256 _desiredDecimals) internal pure returns (uint256) {\n        bytes memory b = bytes(_s);\n\n        uint256 result = 0;\n        uint256 decimalPlaces = 0;\n\n        bool decimals = false;\n        for (uint256 i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                result = result * 10 + (uint256(uint8(b[i])) - 48);\n            }\n\n            if (decimals) {\n                decimalPlaces++;\n            }\n\n            if (b[i] == 0x2E) {\n                require(decimals == false, \"String has multiple decimals\");\n                decimals = true;\n            }\n        }\n\n        require(decimalPlaces <= _desiredDecimals, \"String has too many decimal places\");\n        return result * (10 ** (_desiredDecimals - decimalPlaces));\n    }\n\n    /**\n     * @notice Function that returns a substring from _startIndex to _endIndex (non-inclusive).\n     *\n     * @param _str           String being processed\n     * @param _startIndex    Index to start parsing from\n     * @param _endIndex      Index to stop parsing at (index not included in result)\n     */\n    function substring(string memory _str, uint _startIndex, uint _endIndex) internal pure returns (string memory ) {\n        bytes memory strBytes = bytes(_str);\n        bytes memory result = new bytes(_endIndex-_startIndex);\n        for(uint i = _startIndex; i < _endIndex; i++) {\n            result[i-_startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n}\n"
    },
    "contracts/processors/BaseProcessorV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IKeyHashAdapterV2 } from \"./keyHashAdapters/IKeyHashAdapterV2.sol\";\nimport { INullifierRegistry } from \"./nullifierRegistries/INullifierRegistry.sol\";\n\npragma solidity ^0.8.18;\n\ncontract BaseProcessorV2 is Ownable {\n\n    /* ============ Modifiers ============ */\n    modifier onlyRamp() {\n        require(msg.sender == ramp, \"Only Ramp can call this function\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    address public immutable ramp;\n    IKeyHashAdapterV2 public mailServerKeyHashAdapter;\n    INullifierRegistry public nullifierRegistry;\n    bytes public emailFromAddress;\n    uint256 public timestampBuffer;\n\n    /* ============ Constructor ============ */\n    constructor(\n        address _ramp,\n        IKeyHashAdapterV2 _mailServerKeyHashAdapter,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress,\n        uint256 _timestampBuffer\n    )\n        Ownable()\n    {\n        ramp = _ramp;\n        mailServerKeyHashAdapter = _mailServerKeyHashAdapter;\n        nullifierRegistry = _nullifierRegistry;\n        emailFromAddress = bytes(_emailFromAddress);\n        timestampBuffer = _timestampBuffer;\n    }\n\n    /* ============ External Functions ============ */\n\n    function setMailserverKeyHashAdapter(IKeyHashAdapterV2 _mailServerKeyHashAdapter) external onlyOwner {\n        mailServerKeyHashAdapter = _mailServerKeyHashAdapter;\n    }\n\n    /**\n     * @notice ONLY OWNER: Sets the from email address for validated emails. Check that email address is properly\n     * padded (if necessary). Padding will be dependent on if unpacking functions cut trailing 0s or not.\n     *\n     * @param _emailFromAddress    The from email address for validated emails, MUST BE PROPERLY PADDED\n     */\n    function setEmailFromAddress(string memory _emailFromAddress) external onlyOwner {\n        emailFromAddress = bytes(_emailFromAddress);\n    }\n\n    /**\n     * @notice ONLY OWNER: Sets the timestamp buffer for validated emails. This is the amount of time in seconds\n     * that the timestamp can be off by and still be considered valid. Necessary to build in flexibility with L2\n     * timestamps.\n     *\n     * @param _timestampBuffer    The timestamp buffer for validated emails\n     */\n    function setTimestampBuffer(uint256 _timestampBuffer) external onlyOwner {\n        timestampBuffer = _timestampBuffer;\n    }\n\n    /* ============ External Getters ============ */\n\n    function getEmailFromAddress() external view returns (bytes memory) {\n        return emailFromAddress;\n    }\n\n    function isMailServerKeyHash(bytes32 _keyHash) public view returns (bool) {\n        return IKeyHashAdapterV2(mailServerKeyHashAdapter).isMailServerKeyHash(_keyHash);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _validateAndAddNullifier(bytes32 _nullifier) internal {\n        require(!nullifierRegistry.isNullified(_nullifier), \"Nullifier has already been used\");\n        nullifierRegistry.addNullifier(_nullifier);\n    }\n}\n"
    },
    "contracts/processors/keyHashAdapters/IKeyHashAdapterV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface IKeyHashAdapterV2 {\n    function addMailServerKeyHash(bytes32 _mailserverKeyHash) external;\n    function removeMailServerKeyHash(bytes32 _mailserverKeyHash) external;\n    function getMailServerKeyHashes() external view returns (bytes32[] memory);\n    function isMailServerKeyHash(bytes32 _mailserverKeyHash) external view returns (bool);\n}\n"
    },
    "contracts/processors/nullifierRegistries/INullifierRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface INullifierRegistry {\n    function addNullifier(bytes32 _nullifier) external;\n    function isNullified(bytes32 _nullifier) external view returns(bool);\n}\n"
    },
    "contracts/ramps/hdfc/HDFCSendProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { StringUtils } from \"@zk-email/contracts/utils/StringUtils.sol\";\n\nimport { BaseProcessorV2 } from \"../../processors/BaseProcessorV2.sol\";\nimport { Groth16Verifier } from \"../../verifiers/hdfc_send_verifier.sol\";\nimport { HDFCTimestampParsing } from \"./lib/HDFCTimestampParsing.sol\";\nimport { IKeyHashAdapterV2 } from \"../../processors/keyHashAdapters/IKeyHashAdapterV2.sol\";\nimport { INullifierRegistry } from \"../../processors/nullifierRegistries/INullifierRegistry.sol\";\nimport { IHDFCSendProcessor } from \"./interfaces/IHDFCSendProcessor.sol\";\nimport { StringConversionUtils } from \"../../lib/StringConversionUtils.sol\";\n\npragma solidity ^0.8.18;\n\ncontract HDFCSendProcessor is Groth16Verifier, IHDFCSendProcessor, BaseProcessorV2 {\n    \n    using StringUtils for uint256[];\n    using StringConversionUtils for string;\n\n    /* ============ Constants ============ */\n    uint256 constant PACK_SIZE = 7;\n    uint256 constant IST_OFFSET = 19800;\n\n    /* ============ Constructor ============ */\n    constructor(\n        address _ramp,\n        IKeyHashAdapterV2 _hdfcMailserverKeyHashAdapter,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress,\n        uint256 _timestampBuffer\n    )\n        Groth16Verifier()\n        BaseProcessorV2(\n            _ramp,\n            _hdfcMailserverKeyHashAdapter,\n            _nullifierRegistry,\n            _emailFromAddress,\n            _timestampBuffer\n        )\n    {}\n    \n    /* ============ External Functions ============ */\n    function processProof(\n        IHDFCSendProcessor.SendProof calldata _proof\n    )\n        public\n        override\n        onlyRamp\n        returns(\n            uint256 amount,\n            uint256 timestamp,\n            bytes32 offRamperIdHash,\n            bytes32 onRamperIdHash,\n            bytes32 intentHash\n        )\n    {\n        require(this.verifyProof(_proof.a, _proof.b, _proof.c, _proof.signals), \"Invalid Proof\"); // checks effects iteractions, this should come first\n\n        require(isMailServerKeyHash(bytes32(_proof.signals[0])), \"Invalid mailserver key hash\");\n\n        // Signals [1:4] are the packed from email address\n        string memory fromEmail = _parseSignalArray(_proof.signals, 1, 4);\n        require(keccak256(abi.encodePacked(fromEmail)) == keccak256(emailFromAddress), \"Invalid email from address\");\n\n        // Signals [4:6] is the packed amount, since this is a USDC amount we want to make sure the returned number is\n        // properly padded to 6 decimals. If the parsed has more than 6 figures to the right of the decimal it will revert\n        amount = _parseSignalArray(_proof.signals, 4, 6).stringToUint(6);\n\n        // Signals [6:11] are the packed timestamp, the timestamp is returned as a string in the format, that we need to\n        // parse and convert to a unix timestamp\n        string memory rawTimestamp = _parseSignalArray(_proof.signals, 6, 11);\n        // Add the buffer to build in flexibility with L2 timestamps\n        timestamp = HDFCTimestampParsing._dateStringToTimestamp(rawTimestamp) + timestampBuffer;\n\n        // Signals [11] is the packed onRamperIdHash\n        onRamperIdHash = bytes32(_proof.signals[11]);\n\n        // Signals [12] is the packed offRamper UPI ID hash\n        offRamperIdHash = bytes32(_proof.signals[12]);\n\n        // Check if email has been used previously, if not nullify it so it can't be used again\n        _validateAndAddNullifier(bytes32(_proof.signals[13]));\n\n        // Signals [14] is intentHash\n        intentHash = bytes32(_proof.signals[14]);\n    }\n    \n    /* ============ Internal Functions ============ */\n\n    function _parseSignalArray(uint256[15] calldata _signals, uint8 _from, uint8 _to) internal pure returns (string memory) {\n        uint256[] memory signalArray = new uint256[](_to - _from);\n        for (uint256 i = _from; i < _to; i++) {\n            signalArray[i - _from] = _signals[i];\n        }\n\n        return signalArray.convertPackedBytesToString(signalArray.length * PACK_SIZE, PACK_SIZE);\n    }\n}\n"
    },
    "contracts/ramps/hdfc/interfaces/IHDFCSendProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface IHDFCSendProcessor {\n\n    struct SendProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[15] signals;\n    }\n\n    function processProof(\n        SendProof calldata _proof\n    )\n        external\n    returns(uint256, uint256, bytes32, bytes32, bytes32);\n}\n"
    },
    "contracts/ramps/hdfc/lib/HDFCTimestampParsing.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { DateTime } from \"../../../external/DateTime.sol\";\n\nimport { StringConversionUtils } from \"../../../lib/StringConversionUtils.sol\";\n\npragma solidity ^0.8.18;\n\nlibrary HDFCTimestampParsing {\n\n    using StringConversionUtils for string;\n\n    /**\n     * @notice Iterates through every character in the date string and splits the string at each space or colon. Function will revert\n     * if there are not 8 substrings formed from the split. The substrings are then converted to uints and passed to the DateTime lib\n     * to get the unix timestamp. This function is specific to the date format used by HDFC, not suitable for use with other date formats.\n     */\n    function _dateStringToTimestamp(string memory _dateString) internal pure returns (uint256) {\n        string[8] memory extractedStrings;\n        uint256 breakCounter;\n        uint256 lastBreak;\n        for (uint256 i = 0; i < bytes(_dateString).length; i++) {\n            if (bytes(_dateString)[i] == 0x20 || bytes(_dateString)[i] == 0x3a) {\n                extractedStrings[breakCounter] = _dateString.substring(lastBreak, i);\n                lastBreak = i + 1;\n                breakCounter++;\n            }\n        }\n        // Add last substring to array\n        extractedStrings[breakCounter] = _dateString.substring(lastBreak, bytes(_dateString).length);\n\n        // Check that exactly 8 substrings were found (string is split at 7 different places)\n        require(breakCounter == 7, \"Invalid date string\");\n\n        uint256 unOffsetTimestamp = DateTime.timestampFromDateTime(\n            extractedStrings[3].stringToUint(0), // year\n            _parseMonth(extractedStrings[2]), // month\n            extractedStrings[1].stringToUint(0), // day\n            extractedStrings[4].stringToUint(0), // hour\n            extractedStrings[5].stringToUint(0), // minute\n            extractedStrings[6].stringToUint(0) // second\n        );\n\n        return _calculateTimestampWithOffset(unOffsetTimestamp, extractedStrings[7]);\n    }\n\n    /**\n     * @notice Adds or subtracts an offset from the calculated unOffset timestamp based on the timezone offset string. The timezone offset\n     * string is of the format \"+0530\" or \"-0530\" where the first character is either a \"+\" or a \"-\" and the next 4 characters are hhmm. If\n     * the _timeOffsetString is \"+0530\" then we subtract 5 hours and 30 minutes (19800s) from the unOffset timestamp, to get a GMT timestamp.\n     * We constrain the _timeOffsetString to be 5 characters long to be of the format +/-hhmm.\n     *\n     * @param unOffsetTimestamp     The unix timestamp without any timezone offset applied\n     * @param _timeOffsetString     The timezone offset string indicating the magnitude and direction of the timezone offset\n     */\n    function _calculateTimestampWithOffset(uint256 unOffsetTimestamp, string memory _timeOffsetString) internal pure returns (uint256) {\n        require(bytes(_timeOffsetString).length == 5, \"Invalid timezone offset\");\n        uint256 tzHours = _timeOffsetString.substring(1, 3).stringToUint(0);\n        uint256 tzMinutes = _timeOffsetString.substring(3, 5).stringToUint(0);\n\n        uint256 rawOffset = tzHours * 3600 + tzMinutes * 60;\n\n        // Check if tz offset is positive or negative relative to GMT, 0x2b is the hex value for \"+\" meaning the tz is ahead of GMT and must\n        // be subtracted\n        bytes1 _offsetDirection = bytes(_timeOffsetString.substring(0, 1))[0];\n        return _offsetDirection == 0x2b ? unOffsetTimestamp - rawOffset : unOffsetTimestamp + rawOffset;\n    }\n\n    function _parseMonth(string memory _month) internal pure returns (uint256) {\n        if (keccak256(abi.encodePacked(_month)) == keccak256(\"Jan\")) {\n            return 1;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Feb\")) {\n            return 2;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Mar\")) {\n            return 3;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Apr\")) {\n            return 4;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"May\")) {\n            return 5;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Jun\")) {\n            return 6;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Jul\")) {\n            return 7;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Aug\")) {\n            return 8;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Sep\")) {\n            return 9;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Oct\")) {\n            return 10;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Nov\")) {\n            return 11;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Dec\")) {\n            return 12;\n        } else {\n            revert(\"Invalid month\");\n        }\n    }\n}\n"
    },
    "contracts/verifiers/hdfc_send_verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant deltax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant deltay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant deltay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n    \n    uint256 constant IC0x = 9394740747776187241597029104953484261679012526425116554159524966233999111263;\n    uint256 constant IC0y = 19689273204164097728177651836883812205170784316328518073257553118356569721529;\n    \n    uint256 constant IC1x = 2103298983762510908301138293943056608631520025630826390321569873465337843612;\n    uint256 constant IC1y = 3051671505392171758204845789745109750013350293754815803257290082249002704162;\n    \n    uint256 constant IC2x = 16449197615353463639054592956247688316837441704346035760206288894539930814077;\n    uint256 constant IC2y = 6335892290253569886213727820048151796384993861106408353434365713962828062536;\n    \n    uint256 constant IC3x = 13909339620076649767883466299398757372347682133758066729503408416549131081314;\n    uint256 constant IC3y = 680939940507125217800291279675392811201474158796517777404806360441256992511;\n    \n    uint256 constant IC4x = 5567565339001906931154550109868824777928665956120696988986942291349201008482;\n    uint256 constant IC4y = 14182369860111175092039963088428935808239168726019022822913308258774428350169;\n    \n    uint256 constant IC5x = 4528931757641575110352830627683078786226227744379836276335458021091600396184;\n    uint256 constant IC5y = 18809760409635068499937315446477117440887658318231718225159843539196113242397;\n    \n    uint256 constant IC6x = 217249737022013148790853614054515288744843070463361996227143243753146454558;\n    uint256 constant IC6y = 5843595604928112686285135260361410764846211093271852947892142733907981483475;\n    \n    uint256 constant IC7x = 16382783349015794414606292731397855206031202794459940530289465235845935294599;\n    uint256 constant IC7y = 8313689883004195951872015712057362672054743656979611883792351037811710281664;\n    \n    uint256 constant IC8x = 12091879935696046645654533776196374113414754479661743359672798704639476620661;\n    uint256 constant IC8y = 13607368754408928105528637625253051479212460464623135888354013366424189726618;\n    \n    uint256 constant IC9x = 1427687473863783182488178317364745261019085244973035264375279293174848549312;\n    uint256 constant IC9y = 7042084296523600520065911790797906589532524342562812887761489075993835181146;\n    \n    uint256 constant IC10x = 19579875689027874433809077324776940508857197381913748776343129158527029914029;\n    uint256 constant IC10y = 11360688967181958431013518844967411744837522897538508687548664595854123094206;\n    \n    uint256 constant IC11x = 15489617821697871842044770938846172737438163666835784991442660969573132279238;\n    uint256 constant IC11y = 9208709180384759640941195473336890577882300724746282442631899048305657377731;\n    \n    uint256 constant IC12x = 12219340695113383303094720678815419311566874168360126633878210542379865206498;\n    uint256 constant IC12y = 19748310142198112801532265275227626809399838784073257383942928475531551524126;\n    \n    uint256 constant IC13x = 9809600841880559730361608794352502078553304084649850859459331073975327390409;\n    uint256 constant IC13y = 11320259074840511785906545984642922355663228703151484107043641197226422843416;\n    \n    uint256 constant IC14x = 16059817887658775120436765365711045350150793283463695196041726740989539679801;\n    uint256 constant IC14y = 4842923321162840856934661309117966577909319066986869353905580462534729375402;\n    \n    uint256 constant IC15x = 12339372070549065744144308230683430247880602184204850330715911885647781887335;\n    uint256 constant IC15y = 18316443093151957129338732113138820850818943232578658491484809647188395368957;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[15] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                \n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                \n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                \n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                \n                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n                \n                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n                \n                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n                \n                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n                \n                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))\n                \n                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))\n                \n                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))\n                \n                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))\n                \n                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))\n                \n                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n            checkField(calldataload(add(_pubSignals, 64)))\n            \n            checkField(calldataload(add(_pubSignals, 96)))\n            \n            checkField(calldataload(add(_pubSignals, 128)))\n            \n            checkField(calldataload(add(_pubSignals, 160)))\n            \n            checkField(calldataload(add(_pubSignals, 192)))\n            \n            checkField(calldataload(add(_pubSignals, 224)))\n            \n            checkField(calldataload(add(_pubSignals, 256)))\n            \n            checkField(calldataload(add(_pubSignals, 288)))\n            \n            checkField(calldataload(add(_pubSignals, 320)))\n            \n            checkField(calldataload(add(_pubSignals, 352)))\n            \n            checkField(calldataload(add(_pubSignals, 384)))\n            \n            checkField(calldataload(add(_pubSignals, 416)))\n            \n            checkField(calldataload(add(_pubSignals, 448)))\n            \n            checkField(calldataload(add(_pubSignals, 480)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}