{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@zk-email/contracts/utils/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6;\n\n// https://github.com/nalinbhardwaj/ethdosnumber/blob/main/ethdos-contracts/src/HexStrings.sol\nlibrary StringUtils {\n    bytes16 internal constant ALPHABET = \"0123456789abcdef\";\n    uint256 internal constant DEFAULT_PACK_SIZE = 31;\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(bytes32 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(address account) internal pure returns (string memory) {\n        return toString(abi.encodePacked(account));\n    }\n\n    function stringEq(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n\n    function toString(bytes memory data) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    // 1 packed byte = packSize (usually 31) normal bytes, all in one 255/256-bit value\n    // Note that this is not 32 due to the field modulus of circom\n    function convertPackedByteToString(uint256 packedByte, uint256 packSize)\n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        uint256[] memory packedBytes = new uint256[](1);\n        packedBytes[0] = packedByte;\n        return convertPackedBytesToString(packedBytes, packSize, packSize);\n    }\n\n    // Note: This convenience function removes the max string length check, which may cause misalignment with the circom\n    // If using this, then the circom needs to rangecheck packed length in the circuit itself\n    // This defaults to 31 bytes per packed byte\n    function convertPackedBytesToString(uint256[] memory packedBytes) \n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        return convertPackedBytesToString(packedBytes, packedBytes.length * DEFAULT_PACK_SIZE, DEFAULT_PACK_SIZE);\n    }\n\n    // Unpacks uint256s into bytes and then extracts the non-zero characters\n    // Only extracts contiguous non-zero characters and ensures theres only 1 such state\n    // Note that unpackedLen may be more than packedBytes.length * 8 since there may be 0s\n    // signals is the total number of signals (i.e. bytes) packed into the packedBytes. it defaults to packedBytes.length * packSize\n    function convertPackedBytesToString(uint256[] memory packedBytes, uint256 signals, uint256 packSize)\n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        uint8 state = 0;\n        // bytes: 0 0 0 0 y u s h _ g 0 0 0\n        // state: 0 0 0 0 1 1 1 1 1 1 2 2 2\n        bytes memory nonzeroBytesArray = new bytes(packedBytes.length * packSize);\n        uint256 nonzeroBytesArrayIndex = 0;\n        for (uint16 i = 0; i < packedBytes.length; i++) {\n            uint256 packedByte = packedBytes[i];\n            uint8[] memory unpackedBytes = new uint8[](packSize);\n            for (uint256 j = 0; j < packSize; j++) {\n                unpackedBytes[j] = uint8(packedByte >> (j * 8));\n            }\n            for (uint256 j = 0; j < packSize; j++) {\n                uint256 unpackedByte = unpackedBytes[j]; //unpackedBytes[j];\n                if (unpackedByte != 0) {\n                    nonzeroBytesArray[nonzeroBytesArrayIndex] = bytes1(uint8(unpackedByte));\n                    nonzeroBytesArrayIndex++;\n                    if (state % 2 == 0) {\n                        state += 1;\n                    }\n                } else {\n                    if (state % 2 == 1) {\n                        state += 1;\n                    }\n                }\n                packedByte = packedByte >> 8;\n            }\n        }\n        // TODO: You might want to assert that the state is exactly 1 or 2\n        // If not, that means empty bytse have been removed from the middle and things have been concatenated.\n        // We removed due to some tests failing, but this is not ideal and the require should be uncommented as soon as tests pass with it.\n\n        // require(state == 1 || state == 2, \"Invalid final state of packed bytes in email; more than two non-zero regions found!\");\n        require(state >= 1, \"No packed bytes found! Invalid final state of packed bytes in email; value is likely 0!\");\n        require(nonzeroBytesArrayIndex <= signals, \"Packed bytes more than allowed max number of signals!\");\n        string memory returnValue = removeTrailingZeros(string(nonzeroBytesArray));\n        return returnValue;\n        // Have to end at the end of the email -- state cannot be 1 since there should be an email footer\n    }\n\n    function bytes32ToString(bytes32 input) internal pure returns (string memory) {\n        uint256 i;\n        for (i = 0; i < 32 && input[i] != 0; i++) {}\n        bytes memory resultBytes = new bytes(i);\n        for (i = 0; i < 32 && input[i] != 0; i++) {\n            resultBytes[i] = input[i];\n        }\n        return string(resultBytes);\n    }\n\n    // sliceArray is used to slice an array of uint256s from start-end into a new array of uint256s\n    function sliceArray(uint256[] memory input, uint256 start, uint256 end) internal pure returns (uint256[] memory) {\n        require(start <= end && end <= input.length, \"Invalid slice indices\");\n        uint256[] memory result = new uint256[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            result[i - start] = input[i];\n        }\n        return result;\n    }\n\n    // stringToUint is used to convert a string like \"45\" to a uint256 4\n    function stringToUint(string memory s) internal pure returns (uint256) {\n        bytes memory b = bytes(s);\n        uint256 result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                result = result * 10 + (uint256(uint8(b[i])) - 48);\n            }\n\n            // TODO: Currently truncates decimals\n            if (b[i] == 0x2E) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    // getDomainFromEmail is used to extract the domain from an email i.e. the part after the @\n    function getDomainFromEmail(string memory fromEmail) internal pure returns (string memory) {\n        bytes memory emailBytes = bytes(fromEmail);\n        uint256 atIndex;\n        for (uint256 i = 0; i < emailBytes.length; i++) {\n            if (emailBytes[i] == \"@\") {\n                atIndex = i;\n                break;\n            }\n        }\n\n        bytes memory domainBytes = new bytes(emailBytes.length - atIndex - 1);\n        for (uint256 j = 0; j < domainBytes.length; j++) {\n            domainBytes[j] = emailBytes[atIndex + 1 + j];\n        }\n        return bytes32ToString(bytes32(bytes(domainBytes)));\n    }\n\n    function removeTrailingZeros(string memory input) public pure returns (string memory) {\n        bytes memory inputBytes = bytes(input);\n        uint256 endIndex = inputBytes.length;\n\n        for (uint256 i = 0; i < inputBytes.length; i++) {\n            if (inputBytes[i] == 0) {\n                endIndex = i;\n                break;\n            }\n        }\n\n        bytes memory resultBytes = new bytes(endIndex);\n        for (uint256 i = 0; i < endIndex; i++) {\n            resultBytes[i] = inputBytes[i];\n        }\n\n        return string(resultBytes);\n    }\n\n    // Upper/lower string utils from https://github.com/willitscale/solidity-util/blob/master/lib/Strings.sol\n    /**\n     * Upper\n     *\n     * Converts all the values of a string to their corresponding upper case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to upper case\n     * @return string\n     */\n    function upper(string memory _base) public pure returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _upper(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Lower\n     *\n     * Converts all the values of a string to their corresponding lower case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to lower case\n     * @return string\n     */\n    function lower(string memory _base) public pure returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Upper\n     *\n     * Convert an alphabetic character to upper case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to upper case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a lower case otherwise returns the original value\n     */\n    function _upper(bytes1 _b1) private pure returns (bytes1) {\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\n            return bytes1(uint8(_b1) - 32);\n        }\n\n        return _b1;\n    }\n\n    /**\n     * Lower\n     *\n     * Convert an alphabetic character to lower case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to lower case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a upper case otherwise returns the original value\n     */\n    function _lower(bytes1 _b1) private pure returns (bytes1) {\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n"
    },
    "contracts/external/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ----------------------------------------------------------------------------\n// DateTime Library v2.0\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n//\n// NOTE: This library has been pruned to keep only functions needed by zkp2p\n// ----------------------------------------------------------------------------\n\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day - 32075 + (1461 * (_year + 4800 + (_month - 14) / 12)) / 4\n            + (367 * (_month - 2 - ((_month - 14) / 12) * 12)) / 12\n            - (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) / 4 - OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    )\n        internal\n        pure\n        returns (uint256 timestamp)\n    {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR\n            + minute * SECONDS_PER_MINUTE + second;\n    }\n}\n"
    },
    "contracts/lib/StringConversionUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n// Building on zk-email's StringUtils library we add the ability to handle decimals when\n// converting from string to Uint\nlibrary StringConversionUtils {\n    \n    /**\n     * @notice Function that parses numbers returned as strings including floating point numbers. Returned floating point\n     * numbers are to have the desired amount of decimal specified. If the stringified version of the floating point\n     * number has more decimal places than desired then the function will revert in order to be maximally safe. If\n     * the returned number has multiple floating points then the function will revert.\n     *\n     * Examples: _s = \"12.34\", _expectedDecimals = 6 => 12340000\n     *           _s = \"12.34\", _expectedDecimals = 2 => 1234\n     *           _s = \"12.34\", _expectedDecimals = 1 => REVERT (we never want loss of precision only addition)\n     *           _s = \"12.34.56\", _expectedDecimals = 6 => REVERT (Invalid number)\n     *\n     * @param _s                    String being processed\n     * @param _desiredDecimals      Desired amount of decimal places\n     */\n    function stringToUint(string memory _s, uint256 _desiredDecimals) internal pure returns (uint256) {\n        bytes memory b = bytes(_s);\n\n        uint256 result = 0;\n        uint256 decimalPlaces = 0;\n\n        bool decimals = false;\n        for (uint256 i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                result = result * 10 + (uint256(uint8(b[i])) - 48);\n            }\n\n            if (decimals) {\n                decimalPlaces++;\n            }\n\n            if (b[i] == 0x2E) {\n                require(decimals == false, \"String has multiple decimals\");\n                decimals = true;\n            }\n        }\n\n        require(decimalPlaces <= _desiredDecimals, \"String has too many decimal places\");\n        return result * (10 ** (_desiredDecimals - decimalPlaces));\n    }\n\n    /**\n     * @notice Function that returns a substring from _startIndex to _endIndex (non-inclusive).\n     *\n     * @param _str           String being processed\n     * @param _startIndex    Index to start parsing from\n     * @param _endIndex      Index to stop parsing at (index not included in result)\n     */\n    function substring(string memory _str, uint _startIndex, uint _endIndex) internal pure returns (string memory ) {\n        bytes memory strBytes = bytes(_str);\n        bytes memory result = new bytes(_endIndex-_startIndex);\n        for(uint i = _startIndex; i < _endIndex; i++) {\n            result[i-_startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n}\n"
    },
    "contracts/processors/BaseProcessorV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IKeyHashAdapterV2 } from \"./keyHashAdapters/IKeyHashAdapterV2.sol\";\nimport { INullifierRegistry } from \"./nullifierRegistries/INullifierRegistry.sol\";\n\npragma solidity ^0.8.18;\n\ncontract BaseProcessorV2 is Ownable {\n\n    /* ============ Modifiers ============ */\n    modifier onlyRamp() {\n        require(msg.sender == ramp, \"Only Ramp can call this function\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    address public immutable ramp;\n    IKeyHashAdapterV2 public mailServerKeyHashAdapter;\n    INullifierRegistry public nullifierRegistry;\n    bytes public emailFromAddress;\n\n    /* ============ Constructor ============ */\n    constructor(\n        address _ramp,\n        IKeyHashAdapterV2 _mailServerKeyHashAdapter,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress\n    )\n        Ownable()\n    {\n        ramp = _ramp;\n        mailServerKeyHashAdapter = _mailServerKeyHashAdapter;\n        nullifierRegistry = _nullifierRegistry;\n        emailFromAddress = bytes(_emailFromAddress);\n    }\n\n    /* ============ External Functions ============ */\n\n    function setMailserverKeyHashAdapter(IKeyHashAdapterV2 _mailServerKeyHashAdapter) external onlyOwner {\n        mailServerKeyHashAdapter = _mailServerKeyHashAdapter;\n    }\n\n    /**\n     * @notice ONLY OWNER: Sets the from email address for validated emails. Check that email address is properly\n     * padded (if necessary). Padding will be dependent on if unpacking functions cut trailing 0s or not.\n     *\n     * @param _emailFromAddress    The from email address for validated emails, MUST BE PROPERLY PADDED\n     */\n    function setEmailFromAddress(string memory _emailFromAddress) external onlyOwner {\n        emailFromAddress = bytes(_emailFromAddress);\n    }\n\n    /* ============ External Getters ============ */\n\n    function getEmailFromAddress() external view returns (bytes memory) {\n        return emailFromAddress;\n    }\n\n    function isMailServerKeyHash(bytes32 _keyHash) public view returns (bool) {\n        return IKeyHashAdapterV2(mailServerKeyHashAdapter).isMailServerKeyHash(_keyHash);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _validateAndAddNullifier(bytes32 _nullifier) internal {\n        require(!nullifierRegistry.isNullified(_nullifier), \"Nullifier has already been used\");\n        nullifierRegistry.addNullifier(_nullifier);\n    }\n}\n"
    },
    "contracts/processors/keyHashAdapters/IKeyHashAdapterV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface IKeyHashAdapterV2 {\n    function addMailServerKeyHash(bytes32 _mailserverKeyHash) external;\n    function removeMailServerKeyHash(bytes32 _mailserverKeyHash) external;\n    function getMailServerKeyHashes() external view returns (bytes32[] memory);\n    function isMailServerKeyHash(bytes32 _mailserverKeyHash) external view returns (bool);\n}\n"
    },
    "contracts/processors/nullifierRegistries/INullifierRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface INullifierRegistry {\n    function addNullifier(bytes32 _nullifier) external;\n    function isNullified(bytes32 _nullifier) external view returns(bool);\n}\n"
    },
    "contracts/ramps/hdfc/HDFCRegistrationProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { StringUtils } from \"@zk-email/contracts/utils/StringUtils.sol\";\n\nimport { BaseProcessorV2 } from \"../../processors/BaseProcessorV2.sol\";\nimport { Groth16Verifier } from \"../../verifiers/hdfc_registration_verifier.sol\";\nimport { IKeyHashAdapterV2 } from \"../../processors/keyHashAdapters/IKeyHashAdapterV2.sol\";\nimport { INullifierRegistry } from \"../../processors/nullifierRegistries/INullifierRegistry.sol\";\nimport { IRegistrationProcessor } from \"./interfaces/IRegistrationProcessor.sol\";\n\npragma solidity ^0.8.18;\n\ncontract HDFCRegistrationProcessor is Groth16Verifier, IRegistrationProcessor, BaseProcessorV2 {\n\n    using StringUtils for uint256[];\n\n    /* ============ Constants ============ */\n    uint256 constant public PACK_SIZE = 7;\n    \n    /* ============ Constructor ============ */\n    constructor(\n        address _ramp,\n        IKeyHashAdapterV2 _hdfcMailserverKeyHashAdapter,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress\n    )\n        Groth16Verifier()\n        BaseProcessorV2(_ramp, _hdfcMailserverKeyHashAdapter, _nullifierRegistry, _emailFromAddress)\n    {}\n\n    /* ============ External Functions ============ */\n\n    function processProof(\n        IRegistrationProcessor.RegistrationProof calldata _proof\n    )\n        public\n        override\n        onlyRamp\n        returns(bytes32 userIdHash)\n    {\n        require(this.verifyProof(_proof.a, _proof.b, _proof.c, _proof.signals), \"Invalid Proof\"); // checks effects iteractions, this should come first\n\n        require(isMailServerKeyHash(bytes32(_proof.signals[0])), \"Invalid mailserver key hash\");\n\n        // Signals [1:4] are the packed from email address\n        string memory fromEmail = _parseSignalArray(_proof.signals, 1, 4);\n        require(keccak256(abi.encodePacked(fromEmail)) == keccak256(emailFromAddress), \"Invalid email from address\");\n\n        _validateAndAddNullifier(keccak256(abi.encode(_proof)));\n\n        // Signals [4] is the packed userIdHash\n        userIdHash = bytes32(_proof.signals[4]);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _parseSignalArray(uint256[5] calldata _signals, uint8 _from, uint8 _to) internal pure returns (string memory) {\n        uint256[] memory signalArray = new uint256[](_to - _from);\n        for (uint256 i = _from; i < _to; i++) {\n            signalArray[i - _from] = _signals[i];\n        }\n\n        return signalArray.convertPackedBytesToString(signalArray.length * PACK_SIZE, PACK_SIZE);\n    }\n}\n"
    },
    "contracts/ramps/hdfc/HDFCSendProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { StringUtils } from \"@zk-email/contracts/utils/StringUtils.sol\";\n\nimport { DateTime } from \"../../external/DateTime.sol\";\n\nimport { BaseProcessorV2 } from \"../../processors/BaseProcessorV2.sol\";\nimport { Groth16Verifier } from \"../../verifiers/hdfc_send_verifier.sol\";\nimport { IKeyHashAdapterV2 } from \"../../processors/keyHashAdapters/IKeyHashAdapterV2.sol\";\nimport { INullifierRegistry } from \"../../processors/nullifierRegistries/INullifierRegistry.sol\";\nimport { IHDFCSendProcessor } from \"./interfaces/IHDFCSendProcessor.sol\";\nimport { StringConversionUtils } from \"../../lib/StringConversionUtils.sol\";\n\npragma solidity ^0.8.18;\n\ncontract HDFCSendProcessor is Groth16Verifier, IHDFCSendProcessor, BaseProcessorV2 {\n    \n    using StringUtils for uint256[];\n    using StringConversionUtils for string;\n\n    /* ============ Constants ============ */\n    uint256 constant PACK_SIZE = 7;\n    uint256 constant IST_OFFSET = 19800;\n\n    /* ============ Constructor ============ */\n    constructor(\n        address _ramp,\n        IKeyHashAdapterV2 _hdfcMailserverKeyHashAdapter,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress\n    )\n        Groth16Verifier()\n        BaseProcessorV2(_ramp, _hdfcMailserverKeyHashAdapter, _nullifierRegistry, _emailFromAddress)\n    {}\n    \n    /* ============ External Functions ============ */\n    function processProof(\n        IHDFCSendProcessor.SendProof calldata _proof\n    )\n        public\n        override\n        onlyRamp\n        returns(\n            uint256 amount,\n            uint256 timestamp,\n            bytes32 offRamperIdHash,\n            bytes32 onRamperIdHash,\n            bytes32 intentHash\n        )\n    {\n        require(this.verifyProof(_proof.a, _proof.b, _proof.c, _proof.signals), \"Invalid Proof\"); // checks effects iteractions, this should come first\n\n        require(isMailServerKeyHash(bytes32(_proof.signals[0])), \"Invalid mailserver key hash\");\n\n        // Signals [1:4] are the packed from email address\n        string memory fromEmail = _parseSignalArray(_proof.signals, 1, 4);\n        require(keccak256(abi.encodePacked(fromEmail)) == keccak256(emailFromAddress), \"Invalid email from address\");\n\n        // Signals [4:6] is the packed amount, since this is a USDC amount we want to make sure the returned number is\n        // properly padded to 6 decimals. If the parsed has more than 6 figures to the right of the decimal it will revert\n        amount = _parseSignalArray(_proof.signals, 4, 6).stringToUint(6);\n\n        // Signals [6:11] are the packed timestamp, the timestamp is returned as a string in the format, that we need to\n        // parse and convert to a unix timestamp\n        string memory rawTimestamp = _parseSignalArray(_proof.signals, 6, 11);\n        timestamp = _dateStringToTimestamp(rawTimestamp);\n\n        // Signals [11] is the packed onRamperIdHash\n        onRamperIdHash = bytes32(_proof.signals[11]);\n\n        // Signals [12] is the packed offRamper UPI ID hash\n        offRamperIdHash = bytes32(_proof.signals[12]);\n\n        // Check if email has been used previously, if not nullify it so it can't be used again\n        _validateAndAddNullifier(bytes32(_proof.signals[13]));\n\n        // Signals [14] is intentHash\n        intentHash = bytes32(_proof.signals[14]);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _parseSignalArray(uint256[15] calldata _signals, uint8 _from, uint8 _to) internal pure returns (string memory) {\n        uint256[] memory signalArray = new uint256[](_to - _from);\n        for (uint256 i = _from; i < _to; i++) {\n            signalArray[i - _from] = _signals[i];\n        }\n\n        return signalArray.convertPackedBytesToString(signalArray.length * PACK_SIZE, PACK_SIZE);\n    }\n\n    /**\n     * @notice Iterates through every character in the date string and splits the string at each space or colon. Function will revert\n     * if there are not 8 substrings formed from the split. The substrings are then converted to uints and passed to the DateTime lib\n     * to get the unix timestamp. This function is specific to the date format used by HDFC, not suitable for use with other date formats.\n     */\n    function _dateStringToTimestamp(string memory _dateString) internal pure returns (uint256) {\n        string[8] memory extractedStrings;\n        uint256 breakCounter;\n        uint256 lastBreak;\n        for (uint256 i = 0; i < bytes(_dateString).length; i++) {\n            if (bytes(_dateString)[i] == 0x20 || bytes(_dateString)[i] == 0x3a) {\n                extractedStrings[breakCounter] = _dateString.substring(lastBreak, i);\n                lastBreak = i + 1;\n                breakCounter++;\n            }\n        }\n        // Check that exactly 8 substrings were found (string is split at 7 different places)\n        require(breakCounter == 7, \"Invalid date string\");\n\n        return DateTime.timestampFromDateTime(\n            extractedStrings[3].stringToUint(0), // year\n            _parseMonth(extractedStrings[2]), // month\n            extractedStrings[1].stringToUint(0), // day\n            extractedStrings[4].stringToUint(0), // hour\n            extractedStrings[5].stringToUint(0), // minute\n            extractedStrings[6].stringToUint(0) // second\n        ) - IST_OFFSET;\n    }\n\n    function _parseMonth(string memory _month) internal pure returns (uint256) {\n        if (keccak256(abi.encodePacked(_month)) == keccak256(\"Jan\")) {\n            return 1;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Feb\")) {\n            return 2;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Mar\")) {\n            return 3;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Apr\")) {\n            return 4;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"May\")) {\n            return 5;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Jun\")) {\n            return 6;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Jul\")) {\n            return 7;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Aug\")) {\n            return 8;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Sep\")) {\n            return 9;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Oct\")) {\n            return 10;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Nov\")) {\n            return 11;\n        } else if (keccak256(abi.encodePacked(_month)) == keccak256(\"Dec\")) {\n            return 12;\n        } else {\n            revert(\"Invalid month\");\n        }\n    }\n}\n"
    },
    "contracts/ramps/hdfc/interfaces/IHDFCSendProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface IHDFCSendProcessor {\n\n    struct SendProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[15] signals;\n    }\n\n    function processProof(\n        SendProof calldata _proof\n    )\n        external\n    returns(uint256, uint256, bytes32, bytes32, bytes32);\n}\n"
    },
    "contracts/ramps/hdfc/interfaces/IRegistrationProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface IRegistrationProcessor {\n\n    struct RegistrationProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[5] signals;\n    }\n\n    function processProof(\n        RegistrationProof calldata _proof\n    )\n        external\n    returns (bytes32);\n}\n"
    },
    "contracts/ramps/venmo-v1/interfaces/ISendProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface ISendProcessor {\n\n    struct SendProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[12] signals;\n    }\n\n    function processProof(\n        SendProof calldata _proof\n    )\n        external\n    returns(uint256, uint256, bytes32, bytes32, bytes32);\n}\n"
    },
    "contracts/ramps/venmo-v2/VenmoSendProcessorV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { StringUtils } from \"@zk-email/contracts/utils/StringUtils.sol\";\n\nimport { BaseProcessorV2 } from \"../../processors/BaseProcessorV2.sol\";\nimport { Groth16Verifier } from \"../../verifiers/venmo_send_verifier_v2.sol\";\nimport { IKeyHashAdapterV2 } from \"../../processors/keyHashAdapters/IKeyHashAdapterV2.sol\";\nimport { INullifierRegistry } from \"../../processors/nullifierRegistries/INullifierRegistry.sol\";\nimport { ISendProcessor } from \"../venmo-v1/interfaces/ISendProcessor.sol\";\nimport { StringConversionUtils } from \"../../lib/StringConversionUtils.sol\";\n\npragma solidity ^0.8.18;\n\ncontract VenmoSendProcessorV2 is Groth16Verifier, ISendProcessor, BaseProcessorV2 {\n    \n    using StringUtils for uint256[];\n    using StringConversionUtils for string;\n\n    /* ============ Constants ============ */\n    uint256 constant public PACK_SIZE = 7;\n\n    /* ============ Constructor ============ */\n    constructor(\n        address _ramp,\n        IKeyHashAdapterV2 _venmoMailserverKeyHashAdapter,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress\n    )\n        Groth16Verifier()\n        BaseProcessorV2(_ramp, _venmoMailserverKeyHashAdapter, _nullifierRegistry, _emailFromAddress)\n    {}\n    \n    /* ============ External Functions ============ */\n    function processProof(\n        ISendProcessor.SendProof calldata _proof\n    )\n        public\n        override\n        onlyRamp\n        returns(uint256 amount, uint256 timestamp, bytes32 offRamperIdHash, bytes32 onRamperIdHash, bytes32 intentHash)\n    {\n        require(this.verifyProof(_proof.a, _proof.b, _proof.c, _proof.signals), \"Invalid Proof\"); // checks effects iteractions, this should come first\n\n        require(isMailServerKeyHash(bytes32(_proof.signals[0])), \"Invalid mailserver key hash\");\n\n        // Signals [1:4] are the packed from email address\n        string memory fromEmail = _parseSignalArray(_proof.signals, 1, 4);\n        require(keccak256(abi.encodePacked(fromEmail)) == keccak256(emailFromAddress), \"Invalid email from address\");\n\n        // Signals [4:5] is the packed amount, since this is a USDC amount we want to make sure the returned number is\n        // properly padded to 6 decimals. If the parsed has more than 6 figures to the right of the decimal it will revert\n        amount = _parseSignalArray(_proof.signals, 4, 6).stringToUint(6);\n\n        // Signals [5:7] are the packed timestamp, we do not expect there to be any decimal places in this number so we\n        // specify 0 decimals, if any decimal appears this function will revert\n        timestamp = _parseSignalArray(_proof.signals, 6, 8).stringToUint(0);\n\n        // Signals [8] is the packed offRamperIdHash\n        offRamperIdHash = bytes32(_proof.signals[8]);\n\n        // Signals [9] is the packed onRamperIdHash\n        onRamperIdHash = bytes32(_proof.signals[9]);\n\n        // Check if email has been used previously, if not nullify it so it can't be used again\n        _validateAndAddNullifier(bytes32(_proof.signals[10]));\n\n        // Signals [11] is intentHash\n        intentHash = bytes32(_proof.signals[11]);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _parseSignalArray(uint256[12] calldata _signals, uint8 _from, uint8 _to) internal pure returns (string memory) {\n        uint256[] memory signalArray = new uint256[](_to - _from);\n        for (uint256 i = _from; i < _to; i++) {\n            signalArray[i - _from] = _signals[i];\n        }\n\n        return signalArray.convertPackedBytesToString(signalArray.length * PACK_SIZE, PACK_SIZE);\n    }\n}\n"
    },
    "contracts/verifiers/hdfc_registration_verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 18574627869058290718249846286416066923787357305653818275198119569110729063307;\n    uint256 constant deltax2 = 13915999697294316428724933304884230300804768925316324388637447994944303207122;\n    uint256 constant deltay1 = 6098255674121565970551903974560935137843957314441504769450899063293175181557;\n    uint256 constant deltay2 = 15143967207878882858319171473723762116395973746480761427454690602499031508717;\n\n    \n    uint256 constant IC0x = 6865443700594715891152328791607889526330887414086993633068747938072457241685;\n    uint256 constant IC0y = 10468945301756143970646006543367573774178372611766681195220999860357915797944;\n    \n    uint256 constant IC1x = 10704722446523266721180562643447437149651020230245607194259102672100716655622;\n    uint256 constant IC1y = 13835922647350771093409292403482106984225273572439540259619248291997497190338;\n    \n    uint256 constant IC2x = 9082820476663057749813862646863505694595521088627361022677522902057835975674;\n    uint256 constant IC2y = 2956559811855122372464720724455222044024045806141600873519434424076727259549;\n    \n    uint256 constant IC3x = 3792740326745716842453603765202940845282157902511414580984405164815472719626;\n    uint256 constant IC3y = 13398930886279937280023561976368048826175146409027429215170876003688906362216;\n    \n    uint256 constant IC4x = 1141781699151428606267044235130552909660238448565862470582441408755286403649;\n    uint256 constant IC4y = 16789658000733015308721768726691601134554495877403753820826002406384958395008;\n    \n    uint256 constant IC5x = 12543171042042072636131914829125043929342724675040777036405607612956292855474;\n    uint256 constant IC5y = 4103351600393692854136490223669999878503018507420468298933278541160167154342;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[5] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                \n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                \n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                \n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n            checkField(calldataload(add(_pubSignals, 64)))\n            \n            checkField(calldataload(add(_pubSignals, 96)))\n            \n            checkField(calldataload(add(_pubSignals, 128)))\n            \n            checkField(calldataload(add(_pubSignals, 160)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    },
    "contracts/verifiers/hdfc_send_verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 13715093910953477444594932613394637161592645326267490952383773258932680530785;\n    uint256 constant deltax2 = 6917355939685380899148753334446963866296679557559265300195124805902372568736;\n    uint256 constant deltay1 = 10027537635408556375640886021174498274338207339803607940642263434646237658144;\n    uint256 constant deltay2 = 19825314797083105356154821733414236732602675829642895849779157432388025780748;\n\n    \n    uint256 constant IC0x = 7948712917874849781328365661027367011398916994267746344840851439625837578323;\n    uint256 constant IC0y = 14445610336427827969214783890094209349619216720637343095223018572693254280923;\n    \n    uint256 constant IC1x = 3654976868371838169631577898462947005550108125685649400186026683210975806547;\n    uint256 constant IC1y = 7383470632301847779131345725687431208414525939319998905342796582584383932784;\n    \n    uint256 constant IC2x = 15960136517117002583905099076229506420678130465330836605642076667698312488907;\n    uint256 constant IC2y = 10981003641590459938830276725941498612829685925850889415515039958666798745545;\n    \n    uint256 constant IC3x = 18064147597098347735634254758923927729758051955626895483758091493962336324910;\n    uint256 constant IC3y = 14561976814062079545004557051651175882415454473414826337411715544694691078488;\n    \n    uint256 constant IC4x = 5479872440797886105045613557892343574379959348291323344571145668056905130790;\n    uint256 constant IC4y = 19816668883377774512316396795679515122358992446677555233530823190449668202575;\n    \n    uint256 constant IC5x = 9764995418164291848924916053122788044578670279004409359935206951759326535751;\n    uint256 constant IC5y = 11151240738595525109186562114546767429226785384258075837825604200334229399893;\n    \n    uint256 constant IC6x = 8592289604370662283816667811371636409851377122184258261984779162566069289701;\n    uint256 constant IC6y = 14924863702174947616504138427154175911132478861008643941575632275190130139352;\n    \n    uint256 constant IC7x = 18144310048336844926716356091507529474953804436633311455291234260603469939801;\n    uint256 constant IC7y = 20695654519010539727518673528536864282905304035588394263484365314168181698771;\n    \n    uint256 constant IC8x = 6502380984206062082509747555585722773109086149921002084837192664976139632635;\n    uint256 constant IC8y = 20559694265554344023542679863623632229239552087994730960172389697388976005511;\n    \n    uint256 constant IC9x = 20112907151747105787761530796573701791334087761671369712034010592321424588594;\n    uint256 constant IC9y = 7868275330531868976088552522626764067554872392097431803379373791917043873429;\n    \n    uint256 constant IC10x = 21738568466342470712305504479308744377477421607586657477021567762815751353985;\n    uint256 constant IC10y = 15899136431442502164449286654852349998271141738582178828650897248716421930967;\n    \n    uint256 constant IC11x = 8797574036872579022038442307145559829777119719185174358600414786794648200526;\n    uint256 constant IC11y = 19158045316273481821441527564745598208594831388291307046183673615092116714767;\n    \n    uint256 constant IC12x = 1856159710792583584076099033562199824825551035760525968182870506068750338922;\n    uint256 constant IC12y = 5431689035393664841658365783566955093050903672278814147361678362199701787106;\n    \n    uint256 constant IC13x = 1326184215165888620491943578175089960460457074386949049899809721605475868360;\n    uint256 constant IC13y = 19798068085286831236096103256261325470985925228876029833389405086405680467005;\n    \n    uint256 constant IC14x = 21303925226345182261601479972988106925149727015068245014063996271014722518363;\n    uint256 constant IC14y = 13822581075918761258491041321378418848172590182506086615070972333032971332948;\n    \n    uint256 constant IC15x = 7601301681882298785665130103217482061846330487834337423048688553591898089998;\n    uint256 constant IC15y = 16353595650180105876268966027044363473882857313997670459546834066677499432092;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[15] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                \n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                \n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                \n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                \n                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n                \n                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n                \n                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n                \n                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n                \n                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))\n                \n                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))\n                \n                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))\n                \n                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))\n                \n                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))\n                \n                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n            checkField(calldataload(add(_pubSignals, 64)))\n            \n            checkField(calldataload(add(_pubSignals, 96)))\n            \n            checkField(calldataload(add(_pubSignals, 128)))\n            \n            checkField(calldataload(add(_pubSignals, 160)))\n            \n            checkField(calldataload(add(_pubSignals, 192)))\n            \n            checkField(calldataload(add(_pubSignals, 224)))\n            \n            checkField(calldataload(add(_pubSignals, 256)))\n            \n            checkField(calldataload(add(_pubSignals, 288)))\n            \n            checkField(calldataload(add(_pubSignals, 320)))\n            \n            checkField(calldataload(add(_pubSignals, 352)))\n            \n            checkField(calldataload(add(_pubSignals, 384)))\n            \n            checkField(calldataload(add(_pubSignals, 416)))\n            \n            checkField(calldataload(add(_pubSignals, 448)))\n            \n            checkField(calldataload(add(_pubSignals, 480)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    },
    "contracts/verifiers/venmo_send_verifier_v2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 10075444819728828528059511311364183377585011636666347250599008316664107494584;\n    uint256 constant deltax2 = 19327888262652149651858559507688929247845982563456569545298956783712290831031;\n    uint256 constant deltay1 = 19352801460895629485256782282819819495690526597376096989389923034283130776118;\n    uint256 constant deltay2 = 11668517376357679640486892005206332407941243522830734898219813555969756490527;\n\n    \n    uint256 constant IC0x = 4244199450261939264855608361292422830494076317114087381524682052624987594898;\n    uint256 constant IC0y = 19645046663091251713731947178298410964505911169469312617571077810087266152857;\n    \n    uint256 constant IC1x = 8174035567318043885708495283345132428559378659325609203776402978017320167293;\n    uint256 constant IC1y = 14468913963303826866215469807518170784403093656434266017779773880257875040240;\n    \n    uint256 constant IC2x = 1616603017751755006393562987905285502270823546542543926944627007410237341389;\n    uint256 constant IC2y = 19363001402611389684892375352655759926342431445082754246958964085276938403807;\n    \n    uint256 constant IC3x = 18206398417831844023515176703806764449138507779128726420915001707110434960674;\n    uint256 constant IC3y = 15788322487150289973315668363845259348952014356217153206401112660482394149984;\n    \n    uint256 constant IC4x = 5556506419684194840114638678281266193177223336781663103282498332205775709966;\n    uint256 constant IC4y = 3612832929973582572292953270578481883198123808328242543078950263985599193867;\n    \n    uint256 constant IC5x = 12215062759329544988171802286780059092087193981868301475398051148747302789508;\n    uint256 constant IC5y = 1980305058569746313443850675062124742589110071159814897086099250727381686120;\n    \n    uint256 constant IC6x = 3493933421620238986193524740698678015926658911199434587596433896655331481231;\n    uint256 constant IC6y = 7459045126206245262756783739697871731196375298112634212173672404853831309786;\n    \n    uint256 constant IC7x = 10740551677743158382441062386501298848646053145865823442847610791968594528289;\n    uint256 constant IC7y = 21657167241153225314135589387079002708587418842864077521693977210968021048721;\n    \n    uint256 constant IC8x = 20536476234797263831643189740064053117160337195791856385892992834482370287512;\n    uint256 constant IC8y = 18258699057873865588245369435578918571756469704183085011165098139074862434543;\n    \n    uint256 constant IC9x = 18293662353150822330749373485066335943093182919888710919053977794688677443843;\n    uint256 constant IC9y = 3365197130606871938439382259561012622230793791152518122576869893531830020051;\n    \n    uint256 constant IC10x = 10464268927660994961936771610761322397633069758803976833400107641287034964420;\n    uint256 constant IC10y = 15896600235017903857295002971756639107391153447838560723402307560050234141111;\n    \n    uint256 constant IC11x = 19786751484513045884347111989063082084450406057425687794673931698452346081044;\n    uint256 constant IC11y = 5313251178585910055977156446218999699936391470697302222575669547157687947710;\n    \n    uint256 constant IC12x = 1684055055646723719894355280156760702291183222236626601663480311877006377437;\n    uint256 constant IC12y = 14613128874599604159663378872994588938053027721510091765805321127316501622056;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[12] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                \n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                \n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                \n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                \n                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n                \n                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n                \n                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n                \n                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n                \n                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))\n                \n                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))\n                \n                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n            checkField(calldataload(add(_pubSignals, 64)))\n            \n            checkField(calldataload(add(_pubSignals, 96)))\n            \n            checkField(calldataload(add(_pubSignals, 128)))\n            \n            checkField(calldataload(add(_pubSignals, 160)))\n            \n            checkField(calldataload(add(_pubSignals, 192)))\n            \n            checkField(calldataload(add(_pubSignals, 224)))\n            \n            checkField(calldataload(add(_pubSignals, 256)))\n            \n            checkField(calldataload(add(_pubSignals, 288)))\n            \n            checkField(calldataload(add(_pubSignals, 320)))\n            \n            checkField(calldataload(add(_pubSignals, 352)))\n            \n            checkField(calldataload(add(_pubSignals, 384)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}