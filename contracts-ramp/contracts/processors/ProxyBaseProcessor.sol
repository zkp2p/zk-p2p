//SPDX-License-Identifier: MIT
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
import { Claims } from "@reclaimprotocol/verifier-solidity-sdk/contracts/Claims.sol";

import { AddressArrayUtils } from "../external/AddressArrayUtils.sol";
import { StringArrayUtils } from "../external/StringArrayUtils.sol";
import { INullifierRegistry } from "./nullifierRegistries/INullifierRegistry.sol";
import { IProxyBaseProcessor } from "./interfaces/IProxyBaseProcessor.sol";
import { ClaimVerifier } from "../lib/ClaimVerifier.sol";

pragma solidity ^0.8.18;

contract ProxyBaseProcessor is IProxyBaseProcessor, Ownable {

    using AddressArrayUtils for address[];
    using StringArrayUtils for string[];

    /* ============ State Variables ============ */
    mapping(address => bool) public isWitness;
    address[] public witnesses;
    mapping(string => bool) public isProviderHash;
    string[] public providerHashes;                         // Set of provider hashes that these proofs should be for
    INullifierRegistry public immutable nullifierRegistry;

    /* ============ Events ============ */
    event WitnessAdded(address witness);
    event WitnessRemoved(address witness);
    event ProviderHashAdded(string providerHash);
    event ProviderHashRemoved(string providerHash);

    /* ============ Constructor ============ */
    constructor(
        INullifierRegistry _nulliferRegistry,
        string[] memory _providerHashes
    )
        Ownable()
    {
        nullifierRegistry = _nulliferRegistry;

        for (uint256 i = 0; i < _providerHashes.length; i++) {
            require(!isProviderHash[_providerHashes[i]], "Provider hash already added");
            isProviderHash[_providerHashes[i]] = true;
            providerHashes.push(_providerHashes[i]);

            emit ProviderHashAdded(_providerHashes[i]);
        }
    }

    /* ============ Admin Functions ============ */

    /**
     * ONLY OWNER: Add witness address. Witness must not have been previously added.
     *
     * @param _newWitness    Address of the new witness
     */
    function addWitness(address _newWitness) external onlyOwner {
        require(!isWitness[_newWitness], "Address is already a witness");

        isWitness[_newWitness] = true;
        witnesses.push(_newWitness);

        emit WitnessAdded(_newWitness);
    }

    /**
     * ONLY OWNER: Remove witness address. Witness must have been previously added.
     *
     * @param _removeWitness    Address of witness to be removed
     */
    function removeWitness(address _removeWitness) external onlyOwner {
        require(isWitness[_removeWitness], "Address is not a witness");

        delete isWitness[_removeWitness];
        witnesses.removeStorage(_removeWitness);

        emit WitnessRemoved(_removeWitness);
    }

    /**
     * ONLY OWNER: Add provider hash string. Provider hash must not have been previously added.
     *
     * @param _newProviderHash    New provider hash to be added
     */
    function addProviderHash(string memory _newProviderHash) external onlyOwner {
        require(!isProviderHash[_newProviderHash], "Provider hash already added");

        isProviderHash[_newProviderHash] = true;
        providerHashes.push(_newProviderHash);

        emit ProviderHashAdded(_newProviderHash);
    }

    /**
     * ONLY OWNER: Remove provider hash string. Provider hash must have been previously added.
     *
     * @param _removeProviderHash    Provider hash to be removed
     */
    function removeProviderHash(string memory _removeProviderHash) external onlyOwner {
        require(isProviderHash[_removeProviderHash], "Provider hash not found");

        delete isProviderHash[_removeProviderHash];
        providerHashes.removeStorage(_removeProviderHash);

        emit ProviderHashRemoved(_removeProviderHash);
    }

    /* ============ Public Functions ============ */
    
    /**
     * Verify proof generated by witnesses. Claim is constructed by hashing claimInfo (provider, context, parameters)
     * to get the identifier. And then signing on (identifier, owner, timestamp, epoch) to get claim signature. 
     * This function verifies a claim by performing the following checks on the claim
     * - Calculates the hash of the claimInfo and checks if it matches the identifier in the claim
     * - Checks if the signatures are valid and from the witnesses
     * This function reverts if
     * - No signatures are found on the proof
     * - Number of signatures is not equal to the number of witnesses
     * - ClaimInfo hash does not match the identifier in the claim
     * - Signatures are invalid (not from the witnesses)
     * 
     * DEV NOTE: This function does NOT validate that the claim provider hash is valid. That is the 
     * responsibility of the caller.
     * 
     * Parts of the code are adapted from: https://basescan.org/address/0x7281630e4346dd4c0b7ae3b4689c1d0102741410#code
     *    
     * @param proof                 Proof to be verified
     */
    function verifyProofSignatures(Proof memory proof) public view returns (bool) {

        // create signed claim using claimData and signature.
        require(proof.signedClaim.signatures.length > 0, "No signatures");
        Claims.SignedClaim memory signed = Claims.SignedClaim(
            proof.signedClaim.claim,
            proof.signedClaim.signatures
        );

        // check if the hash from the claimInfo is equal to the infoHash in the claimData
        bytes32 hashed = Claims.hashClaimInfo(proof.claimInfo);
        require(proof.signedClaim.claim.identifier == hashed, "ClaimInfo hash doesn't match");

        // Recover signers of the signed claim
        address[] memory signedWitnesses = Claims.recoverSignersOfSignedClaim(signed);

        // check if the number of signatures is equal to the number of witnesses
        require(
            signedWitnesses.length == witnesses.length,
            "Number of signatures not equal to number of witnesses"
        );

        // Check signatures are from witnesses
        for (uint256 i = 0; i < signed.signatures.length; i++) {
            bool found = false;
            for (uint j = 0; j < witnesses.length; j++) {
                if (signedWitnesses[i] == witnesses[j]) {
                    found = true;
                    break;
                }
            }
            require(found, "Signature not appropriate");
        }

        return true;
    }


    /* ============ View Functions ============ */

    function getWitnesses() external view returns (address[] memory) {
        return witnesses;
    }

    function getProviderHashes() external view returns (string[] memory) {
        return providerHashes;
    }

    /* ============ Internal Functions ============ */

    function _validateProviderHash(string memory _providerHash) internal view returns (bool) {
        return isProviderHash[_providerHash];
    }
    
    function _validateAndAddSigNullifier(bytes[] memory _sigArray) internal {
        bytes32 nullifier = keccak256(abi.encode(_sigArray));
        require(!nullifierRegistry.isNullified(nullifier), "Nullifier has already been used");
        nullifierRegistry.addNullifier(nullifier);
    }

    function _validateAndAddNullifier(bytes32 _nullifier) internal {
        require(!nullifierRegistry.isNullified(_nullifier), "Nullifier has already been used");
        nullifierRegistry.addNullifier(_nullifier);
    }
}
